<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="最近在看deno源码，遇到deno中使用FlatBuffers来处理js与rust，c++交互过程中的序列化和反序列化，对于我来说是个新的工具所以打算翻源码了解一下它的工作原理及deno使用它的理由。"/><link rel="alternate" href="/default" title="ljy" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://example.com/2018/08/06/Deno 源码速览/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>Deno 源码速览 - ljy</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">ljy</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ljy</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Deno 源码速览
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-08-06
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binding-cc"><span class="toc-text">binding.cc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main-ts"><span class="toc-text">main.ts</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>最近看了Ryan Dahl的10 Things I Regret About Node.js。对deno产生了兴趣，所以花了几天时间细读了deno的代码(0.1.0版本)。<br>项目的初衷是打造一个基于v8引擎的安全的TypeScript运行时，同时实现HTML5的基础API，首先整个项目的用了ts, c++, rust来写, ts代码在编译阶段用parcel合并在一起放入了v8的snapshot，用于用户端的接口调用。c++主要处理v8相关的部分。rust作为核心部分承接了deno的主要功能实现。</p>
<p>看过node的同学应该都清楚, node中使用process.binding的方式来实现js与c++之间的交互, 在node源码阅读中往往出现两端相互绑定耦合, 代码显得比较混乱, 在deno中摒弃了这种方式取而代之的是使用dispatch的方式发送指令，rust端接受到特定指令之后再做处理，中间使用flatbuffers来做序列化。相比较之下deno的架构显得更简单明了，也更安全可控。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>目前版本中deno初始化分两种情况，一种是from filesystem, 一种是from snapshot。前者是没有snapshot直接从文件系统中读取bundle.js来节省编译时间适用于开发模式，而生产模式下使用后者来节省启动时间。<br>from snapshot相对复杂，这边讲解这中初始化方式，首先在build阶段会直接运行snapshot_creator来生成v8初始化要用到的snapshot, 这个可执行文件主要作用在于调用InitializeContext绑定全局变量，然后把全局上下文context绑定到snapshot中，然后以blob形式输出到文件系统中，InitializeContext会在下文讲解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// snapshot_creator.cc</span></span><br><span class="line"><span class="function">v8::StartupData <span class="title">MakeSnapshot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* js_filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; js_source,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>* source_map)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* creator = <span class="keyword">new</span> v8::SnapshotCreator(external_references);</span><br><span class="line">  <span class="keyword">auto</span>* isolate = creator-&gt;GetIsolate();</span><br><span class="line">  v8::<span class="function">Isolate::Scope <span class="title">isolate_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">v8::HandleScope <span class="title">handle_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> context = v8::Context::New(isolate);</span><br><span class="line">    InitializeContext(isolate, context, js_filename, js_source, source_map);</span><br><span class="line">    creator-&gt;SetDefaultContext(context, v8::SerializeInternalFieldsCallback(</span><br><span class="line">                                            SerializeInternalFields, <span class="literal">nullptr</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> snapshot_blob =</span><br><span class="line">      creator-&gt;CreateBlob(v8::SnapshotCreator::FunctionCodeHandling::kClear);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> snapshot_blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在from_snapshot中使用汇编asm的方式来读取blob，由于没接触过汇编这部分的代码超出了我的认知范围，在之前是直接读取文件形式来读取snapshot blob, 在目前版本中使用asm我猜想应该是在优化读取速度。<br>NewFromSnapshot创建Deno struct。然后做v8初始化.这边传入的cb叫做msg_from_js(见main.rs), 是rust处理js传过来的msg的入口函数，会在libdeno.send中调用它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/ from_snapshot.cc</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LIBDENO_TEST</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;.data\n&quot;</span></span><br><span class="line">    <span class="string">&quot;deno_snapshot_start: .incbin \&quot;gen/snapshot_libdeno_test.bin\&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;deno_snapshot_end:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;.globl deno_snapshot_start;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;.globl deno_snapshot_end;&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;.data\n&quot;</span></span><br><span class="line">    <span class="string">&quot;deno_snapshot_start: .incbin \&quot;gen/snapshot_deno.bin\&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;deno_snapshot_end:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;.globl deno_snapshot_start;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;.globl deno_snapshot_end;&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// LIBDENO_TEST</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Deno* <span class="title">NewFromSnapshot</span><span class="params">(<span class="keyword">void</span>* data, deno_recv_cb cb)</span> </span>&#123;</span><br><span class="line">  Deno* d = <span class="keyword">new</span> Deno;</span><br><span class="line">  d-&gt;currentArgs = <span class="literal">nullptr</span>;</span><br><span class="line">  d-&gt;cb = cb;</span><br><span class="line">  d-&gt;data = data;</span><br><span class="line">  v8::Isolate::CreateParams params;</span><br><span class="line">  params.array_buffer_allocator =</span><br><span class="line">      v8::ArrayBuffer::Allocator::NewDefaultAllocator();</span><br><span class="line">  params.external_references = external_references;</span><br><span class="line"></span><br><span class="line">  CHECK_NE(&amp;deno_snapshot_start, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">int</span> snapshot_len =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(&amp;deno_snapshot_end - &amp;deno_snapshot_start);</span><br><span class="line">  <span class="keyword">static</span> v8::StartupData snapshot = &#123;&amp;deno_snapshot_start, snapshot_len&#125;;</span><br><span class="line">  params.snapshot_blob = &amp;snapshot;</span><br><span class="line"></span><br><span class="line">  v8::Isolate* isolate = v8::Isolate::New(params);</span><br><span class="line">  AddIsolate(d, isolate);</span><br><span class="line"></span><br><span class="line">  <span class="function">v8::Locker <span class="title">locker</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  v8::<span class="function">Isolate::Scope <span class="title">isolate_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">v8::HandleScope <span class="title">handle_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> context =</span><br><span class="line">        v8::Context::New(isolate, <span class="literal">nullptr</span>, v8::MaybeLocal&lt;v8::ObjectTemplate&gt;(),</span><br><span class="line">                         v8::MaybeLocal&lt;v8::Value&gt;(),</span><br><span class="line">                         v8::DeserializeInternalFieldsCallback(</span><br><span class="line">                             DeserializeInternalFields, <span class="literal">nullptr</span>));</span><br><span class="line">    d-&gt;context.Reset(d-&gt;isolate, context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.rs</span></span><br><span class="line">binding::deno_new(</span><br><span class="line">  deno_box.as_ref() as *<span class="keyword">const</span> _ as *<span class="keyword">const</span> c_void,</span><br><span class="line">  handlers::msg_from_js,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="binding-cc"><a href="#binding-cc" class="headerlink" title="binding.cc"></a>binding.cc</h3><p>初始化的时候会调用InitializeContext，InitializeContext函数中定义了全局变量libdeno, 并在libdeno上挂载了3个方法, 执行bundle.js。print很简单就是打印内容，也是deno中console.log的内部实现。接下来就讲讲send和recv两个deno中使用最常用的两个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binding.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeContext</span><span class="params">(v8::Isolate* isolate, v8::Local&lt;v8::Context&gt; context,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span>* js_filename, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; js_source,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>* source_map)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">auto</span> deno_val = v8::Object::New(isolate);</span><br><span class="line">  CHECK(global-&gt;Set(context, deno::v8_str(<span class="string">&quot;libdeno&quot;</span>), deno_val).FromJust());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> print_tmpl = v8::FunctionTemplate::New(isolate, Print);</span><br><span class="line">  <span class="keyword">auto</span> print_val = print_tmpl-&gt;GetFunction(context).ToLocalChecked();</span><br><span class="line">  CHECK(deno_val-&gt;Set(context, deno::v8_str(<span class="string">&quot;print&quot;</span>), print_val).FromJust());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> recv_tmpl = v8::FunctionTemplate::New(isolate, Recv);</span><br><span class="line">  <span class="keyword">auto</span> recv_val = recv_tmpl-&gt;GetFunction(context).ToLocalChecked();</span><br><span class="line">  CHECK(deno_val-&gt;Set(context, deno::v8_str(<span class="string">&quot;recv&quot;</span>), recv_val).FromJust());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> send_tmpl = v8::FunctionTemplate::New(isolate, Send);</span><br><span class="line">  <span class="keyword">auto</span> send_val = send_tmpl-&gt;GetFunction(context).ToLocalChecked();</span><br><span class="line">  CHECK(deno_val-&gt;Set(context, deno::v8_str(<span class="string">&quot;send&quot;</span>), send_val).FromJust());</span><br><span class="line"></span><br><span class="line">  skip_onerror = <span class="literal">true</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> source = deno::v8_str(js_source.c_str());</span><br><span class="line">    CHECK(</span><br><span class="line">        deno_val-&gt;Set(context, deno::v8_str(<span class="string">&quot;mainSource&quot;</span>), source).FromJust());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> r = deno::ExecuteV8StringSource(context, js_filename, source);</span><br><span class="line">    CHECK(r);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  skip_onerror = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看Send，上文中也提到了这部分的功能，传过来的buf通过ExportBuf转化成内部可用的deno_buf, d-&gt;cb(d, buf)调用handlers.rs中msg_from_js. 那d-&gt;currentArgs = &args;的作用是什么呢？先不急，我们顺着调用栈看下去自然会明白。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  v8::Isolate* isolate = args.GetIsolate();</span><br><span class="line">  Deno* d = <span class="keyword">static_cast</span>&lt;Deno*&gt;(isolate-&gt;GetData(<span class="number">0</span>));</span><br><span class="line">  DCHECK_EQ(d-&gt;isolate, isolate);</span><br><span class="line"></span><br><span class="line">  <span class="function">v8::Locker <span class="title">locker</span><span class="params">(d-&gt;isolate)</span></span>;</span><br><span class="line">  <span class="function">v8::EscapableHandleScope <span class="title">handle_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"></span><br><span class="line">  CHECK_EQ(args.Length(), <span class="number">1</span>);</span><br><span class="line">  v8::Local&lt;v8::Value&gt; ab_v = args[<span class="number">0</span>];</span><br><span class="line">  CHECK(ab_v-&gt;IsArrayBufferView());</span><br><span class="line">  <span class="keyword">auto</span> buf = ExportBuf(isolate, v8::Local&lt;v8::ArrayBufferView&gt;::Cast(ab_v));</span><br><span class="line"></span><br><span class="line">  DCHECK_EQ(d-&gt;currentArgs, <span class="literal">nullptr</span>);</span><br><span class="line">  d-&gt;currentArgs = &amp;args;</span><br><span class="line"></span><br><span class="line">  d-&gt;cb(d, buf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Buffer is only valid until the end of the callback.</span></span><br><span class="line">  <span class="comment">// TODO(piscisaureus):</span></span><br><span class="line">  <span class="comment">//   It&#x27;s possible that data in the buffer is needed after the callback</span></span><br><span class="line">  <span class="comment">//   returns, e.g. when the handler offloads work to a thread pool, therefore</span></span><br><span class="line">  <span class="comment">//   make the callback responsible for releasing the buffer.</span></span><br><span class="line">  FreeBuf(buf);</span><br><span class="line"></span><br><span class="line">  d-&gt;currentArgs = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在msg_from_js中先经过flatbuffers反序列化，做相应处理之后调用deno_set_response。在deno_set_response中看到了我们熟悉的GetReturnValue().Set()设置了libdeno.send的返回值，<code>d-&gt;currentArgs</code>就是用来传递Send中的args。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">msg_from_js</span></span>(d: *<span class="keyword">const</span> DenoC, buf: deno_buf) &#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = <span class="keyword">unsafe</span> &#123; std::slice::from_raw_parts(buf.data_ptr, buf.data_len) &#125;;</span><br><span class="line">  <span class="keyword">let</span> base = msg::get_root_as_base(bytes);</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> builder = FlatBufferBuilder::new();</span><br><span class="line">  <span class="keyword">let</span> msg_type = base.msg_type();</span><br><span class="line">  <span class="keyword">let</span> result: HandlerResult = <span class="keyword">match</span> msg_type &#123;</span><br><span class="line">    msg::Any::Start =&gt; handle_start(d, &amp;<span class="keyword">mut</span> builder),</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the synchronous response, the value returned from deno.send().</span></span><br><span class="line">  <span class="comment">// null_buf is a special case that indicates success.</span></span><br><span class="line">  <span class="keyword">if</span> buf != null_buf() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; binding::deno_set_response(d, buf) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deno_set_response</span><span class="params">(Deno* d, deno_buf buf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ab = deno::ImportBuf(d-&gt;isolate, buf);</span><br><span class="line">  d-&gt;currentArgs-&gt;GetReturnValue().Set(ab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看Recv函数, 它接受一个js函数赋值给d-&gt;recv，我们看到deno_send用到了recv。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recv</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  v8::Isolate* isolate = args.GetIsolate();</span><br><span class="line">  Deno* d = <span class="keyword">reinterpret_cast</span>&lt;Deno*&gt;(isolate-&gt;GetData(<span class="number">0</span>));</span><br><span class="line">  DCHECK_EQ(d-&gt;isolate, isolate);</span><br><span class="line"></span><br><span class="line">  <span class="function">v8::HandleScope <span class="title">handle_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!d-&gt;recv.IsEmpty()) &#123;</span><br><span class="line">    isolate-&gt;ThrowException(v8_str(<span class="string">&quot;deno.recv already called.&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v8::Local&lt;v8::Value&gt; v = args[<span class="number">0</span>];</span><br><span class="line">  CHECK(v-&gt;IsFunction());</span><br><span class="line">  v8::Local&lt;v8::Function&gt; func = v8::Local&lt;v8::Function&gt;::Cast(v);</span><br><span class="line"></span><br><span class="line">  d-&gt;recv.Reset(isolate, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deno_send</span><span class="params">(Deno* d, deno_buf buf)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">auto</span> recv = d-&gt;recv.Get(d-&gt;isolate);</span><br><span class="line">  <span class="keyword">if</span> (recv.IsEmpty()) &#123;</span><br><span class="line">    d-&gt;last_exception = <span class="string">&quot;deno.recv has not been called.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v8::Local&lt;v8::Value&gt; args[<span class="number">1</span>];</span><br><span class="line">  args[<span class="number">0</span>] = deno::ImportBuf(d-&gt;isolate, buf);</span><br><span class="line">  recv-&gt;Call(context-&gt;Global(), <span class="number">1</span>, args);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺藤摸瓜，我们最终定位到了handlers.rs中的<code>send_base</code>函数用到了<code>deno_send</code>。和Send函数中同步返回执行结果不同的是，send_base主要用于fetch, settimeout等操作，也就是异步返回执行结果，deno_send相当于一个回调函数，使用libdeno.recv来定义它。</p>
<h3 id="main-ts"><a href="#main-ts" class="headerlink" title="main.ts"></a>main.ts</h3><p>通过上文的讲解，我们再来看看typescript中是怎么使用libdeno的上述几个方法的。我们主要是看main.ts.首先定义异步回调onMessage。发送Start命令用来调试整个回路，然后<code>compiler.run</code>执行用户代码, onMessage与msg_from_js类似，用于分发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startMsg</span>(<span class="params">cmdId: number</span>): <span class="title">Uint8Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> builder = <span class="keyword">new</span> flatbuffers.Builder();</span><br><span class="line">  fbs.Start.startStart(builder);</span><br><span class="line">  <span class="keyword">const</span> startOffset = fbs.Start.endStart(builder);</span><br><span class="line">  fbs.Base.startBase(builder);</span><br><span class="line">  fbs.Base.addCmdId(builder, cmdId);</span><br><span class="line">  fbs.Base.addMsg(builder, startOffset);</span><br><span class="line">  fbs.Base.addMsgType(builder, fbs.Any.Start);</span><br><span class="line">  builder.finish(fbs.Base.endBase(builder));</span><br><span class="line">  <span class="keyword">return</span> builder.asUint8Array();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">ui8: <span class="built_in">Uint8Array</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bb = <span class="keyword">new</span> flatbuffers.ByteBuffer(ui8);</span><br><span class="line">  <span class="keyword">const</span> base = fbs.Base.getRootAsBase(bb);</span><br><span class="line">  <span class="keyword">switch</span> (base.msgType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> fbs.Any.FetchRes: &#123;</span><br><span class="line">      <span class="keyword">const</span> msg = <span class="keyword">new</span> fbs.FetchRes();</span><br><span class="line">      assert(base.msg(msg) != <span class="literal">null</span>);</span><br><span class="line">      onFetchRes(base, msg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> fbs.Any.TimerReady: &#123;</span><br><span class="line">      <span class="keyword">const</span> msg = <span class="keyword">new</span> fbs.TimerReady();</span><br><span class="line">      assert(base.msg(msg) != <span class="literal">null</span>);</span><br><span class="line">      timers.onMessage(msg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      assert(<span class="literal">false</span>, <span class="string">&quot;Unhandled message type&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">denoMain</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置回调</span></span><br><span class="line">  libdeno.recv(onMessage);</span><br><span class="line">  <span class="keyword">const</span> compiler = DenoCompiler.instance();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cmdId = assignCmdId();</span><br><span class="line">  <span class="keyword">const</span> res = libdeno.send(startMsg(cmdId));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(ry) Remove this conditional once main.rs gets up to speed.</span></span><br><span class="line">  <span class="keyword">if</span> (res == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The &#x27;Start&#x27; message got a null response.  Normally this would</span></span><br><span class="line"><span class="string">    be an error but main.rs currently does this.&quot;); Exiting without error.`</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Deserialize res into startResMsg.</span></span><br><span class="line">  <span class="keyword">const</span> bb = <span class="keyword">new</span> flatbuffers.ByteBuffer(res);</span><br><span class="line">  <span class="keyword">const</span> base = fbs.Base.getRootAsBase(bb);</span><br><span class="line">  assert(fbs.Any.StartRes === base.msgType());</span><br><span class="line">  <span class="keyword">const</span> startResMsg = <span class="keyword">new</span> fbs.StartRes();</span><br><span class="line">  assert(base.msg(startResMsg) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  setLogDebug(startResMsg.debugFlag());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cwd = startResMsg.cwd();</span><br><span class="line">  log(<span class="string">&quot;cwd&quot;</span>, cwd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> argv: string[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; startResMsg.argvLength(); i++) &#123;</span><br><span class="line">    argv.push(startResMsg.argv(i));</span><br><span class="line">  &#125;</span><br><span class="line">  log(<span class="string">&quot;argv&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> inputFn = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (!inputFn) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;No input script specified.&quot;</span>);</span><br><span class="line">    os.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行用户代码</span></span><br><span class="line">  compiler.run(inputFn, <span class="string">`<span class="subst">$&#123;cwd&#125;</span>/`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deno的整个流程就是这些，至于详细的功能，比如fetch，timer等功能由于篇幅没有展开来讲，可以看到deno这个项目虽然处于非常早期，但整个架构已经很清晰。同时deno这种非常有意思的项目对于我们前端开发者开阔视野，认识前端最前沿技术发展很有帮助，deno社区也非常活跃，笔者有空就会去issue上看这些设计背后的思考。虽然deno离用在生产环境上还有很长的距离，甚至应用场景也是模糊，但是国外同行的开拓精神和设计思想是很值得我们去学习借鉴的。</p>

      </div>
      
      <footer class="post-footer">
        
        <nav class="post-nav"><a class="prev" href="/2018/09/23/parcel%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">parcel中的多线程</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2018/08/02/FlatBuffers%E5%8E%9F%E7%90%86/">
        <span class="next-text nav-default">FlatBuffers原理</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:loujiayu7@gmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/loujiayu" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/loujiayu">Even</a>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
